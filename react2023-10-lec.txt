npm create vite@latest .
select react
npm i 
npm run dev

exports.getSingleProduct = async(req,res,next) => {
	 const product = await Product.findById(req.params.id);
	 if(!product) {
	 		return res.status(404).json({
	 			success: false,
	 			message: 'Product not found'
	 		})
	 }
	 res.status(200).json({
	 	success: true,
	 	product
	 })
}

exports.updateProduct = async (req, res, next) => {
	let product = await Product.findById(req.params.id);
	console.log(req.body)
	if (!product) {
		return res.status(404).json({
			success: false,
			message: 'Product not found'
		})
	}
	product = await Product.findOneAndUpdate(req.param.id, req.body, {
		new: true,
	})
	if (!product) {
		return res.status(404).json({
			success: false,
			message: 'Product not updated'
		})
	}
	res.status(200).json({
		success: true,
		product
	})
}

exports.deleteProduct = async(req,res,next) => {
	const product = await Product.findById(req.params.id);
	if(!product) {
	 		return res.status(404).json({
	 			success: false,
	 			message: 'Product not found'
	 		})
	 }
	 await product.remove();
	 res.status(200).json({
	 	success: true,
	 	message: 'Product deleted'
	 })
}

router.get('/products', getProducts)
router.post('/product/new',newProduct)
router.get('/product/:id', getSingleProduct);
router.route('/admin/product/:id').put(updateProduct).delete(deleteProduct);

utils/apiFeatures.js
class APIFeatures {
    constructor(query, queryStr) {
        this.query = query;
        this.queryStr = queryStr;
    }

    search() {
        const keyword = this.queryStr.keyword ? {
            name: {
                $regex: this.queryStr.keyword,
                $options: 'i'
            }
        } : {}
        console.log(keyword,this.query);
        this.query = this.query.find({ ...keyword });
        return this;
    }

    filter() {

        const queryCopy = { ...this.queryStr };
        console.log(queryCopy);
        // Removing fields from the query
        const removeFields = ['keyword', 'limit', 'page']
        removeFields.forEach(el => delete queryCopy[el]);
        
        // Advance filter for price, ratings etc
        let queryStr = JSON.stringify(queryCopy);
        console.log(queryStr);
        queryStr = queryStr.replace(/\b(gt|gte|lt|lte)\b/g, match => `$${match}`)

        
        this.query = this.query.find(JSON.parse(queryStr));
        console.log(JSON.parse(queryStr));
        return this;
    }

    pagination(resPerPage) {
        const currentPage = Number(this.queryStr.page) || 1;
        const skip = resPerPage * (currentPage - 1);

        this.query = this.query.limit(resPerPage).skip(skip);
        return this;
    }
}


export default APIFeatures

exports.getProducts = catchAsyncErrors(async (req,res,next) => {
	
	const resPerPage = 4;
	const productsCount = await Product.countDocuments();
	const apiFeatures = new APIFeatures(Product.find(),req.query).search().filter(); 

	// const products = await Product.find();
	apiFeatures.pagination(resPerPage);
	const products = await apiFeatures.query;
	res.status(200).json({
		success: true,
		count: products.length,
		productsCount,
		products
	})
})
//search
http://localhost:4001/api/v1/products?keyword=apple
products?keyword=apple&price[gte]=1&price[lte]=200

models/userconst mongoose = require('mongoose');
const validator = require('validator');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const crypto = require('crypto')

const userSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Please enter your name'],
        maxLength: [30, 'Your name cannot exceed 30 characters']
    },
    email: {
        type: String,
        required: [true, 'Please enter your email'],
        unique: true,
        validate: [validator.isEmail, 'Please enter valid email address']
    },
    password: {
        type: String,
        required: [true, 'Please enter your password'],
        minlength: [6, 'Your password must be longer than 6 characters'],
        select: false
    },
    avatar: {
        public_id: {
            type: String,
            required: true
        },
        url: {
            type: String,
            required: true
        }
    },
    role: {
        type: String,
        default: 'user'
    },
    createdAt: {
        type: Date,
        default: Date.now
    },
    resetPasswordToken: String,
    resetPasswordExpire: Date

})


 userSchema.pre('save', async function (next) {
     if (!this.isModified('password')) {
         next()
  	}

     this.password = await bcrypt.hash(this.password, 10)
 });

module.exports = mongoose.model('User', userSchema);

authController
const User = require('../models/user');

const ErrorHandler = require('../utils/errorHandler');

exports.registerUser = async (req, res, next) => {
	const { name, email, password } = req.body;
	 const user = await User.create({
        name,
        email,
        password,
        avatar: {
            public_id: 'avatars/sxamgzs1aj91rqahehqe',
            url: 'https://res.cloudinary.com/dgneiaky7/image/upload/v1649818466/avatars/sxamgzs1aj91rqahehqe.png'
        }
    })
	 //test token
	 // const token = user.getJwtToken();
	 
	  res.status(201).json({
	  	success:true,
	  	user,
	 // 	token
	  })
	//  sendToken(user, 200, res)
};

routes/auth
const express = require('express');
const router = express.Router();

const { registerUser, } = require('../controllers/authController');
router.post('/register',registerUser);
// router.post('/login',loginUser);

// router.post('/password/forgot',forgotPassword);
// router.put('/password/reset/:token',resetPassword);

// router.get('/logout',logout);

module.exports = router;

app.js
const auth = require('./routes/auth');
app.use('/api/v1',auth);




